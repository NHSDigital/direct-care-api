# pylint: disable=C0116, C0115, C0114

import asyncio
import logging
import time
from time import sleep
from typing import Generator

import pytest
from pydantic import BaseModel


#  from shared.common import concurrent_tasks, create_task, run_in_executor
from shared.logger import (
    action_logging,
    add_fields,
    Constants,
    log_action,
    LogLevel,
    logging_context,
)
from shared.logger import app_logger


class TestExplodingModel(BaseModel):
    name: str


def test_logging_simple(log_capture):
    std_out, std_err = log_capture

    app_logger.info(lambda: {"test": 123})

    assert 1 == len(std_out)
    assert 0 == len(std_err)
    assert 123 == std_out[0]["test"]


def test_logging_simple_is_lazy(log_capture):
    std_out, std_err = log_capture

    prev_level = app_logger.log_at_level

    try:
        app_logger.log_at_level = logging.WARN

        calls = []

        def create_logging_args():
            calls.append(1)
            return {"things": 123}

        app_logger.info(create_logging_args)

        assert 0 == len(std_out)
        assert 0 == len(std_err)
        assert 0 == len(calls)
    finally:
        app_logger.log_at_level = prev_level


def test_logging_default_logger(log_capture):
    std_out, std_err = log_capture
    level = logging.root.level
    logging.root.setLevel(LogLevel.INFO)
    logging.info("test")
    logging.root.setLevel(level)
    assert 0 == len(std_err)
    assert "test" == std_out[0]["message"]


def test_log_exception(log_capture):
    std_out, std_err = log_capture

    try:
        raise ValueError("testing")
    except ValueError:
        app_logger.exception(lambda: dict(things=123))

    assert 0 == len(std_out)
    assert 1 == len(std_err)

    err = std_err[0]
    assert "testing" == err["ex"]
    assert "builtins.ValueError" == err["ex_type"]


def test_with_action_logging(log_capture):
    std_out, std_err = log_capture

    with action_logging(field=123):
        num = 1 + 1

        add_fields(num=num)

    assert 0 == len(std_err)
    assert 1 == len(std_out)

    log = std_out[0]

    assert 2 == log["num"]
    assert 123 == log["field"]

    assert Constants.TASK_UUID_FIELD in log


def test_with_action_logging_exploded_model(log_capture):
    std_out, std_err = log_capture

    with action_logging(field=TestExplodingModel({"name": "vic"})):
        num = 1 + 1

        add_fields(num=num)

    assert 0 == len(std_err)
    assert 1 == len(std_out)

    log = std_out[0]

    assert 2 == log["num"]

    assert isinstance(log["field"], dict), "Model was not exploded to primitive form!"
    assert "vic" == log["field"]["name"]

    assert Constants.TASK_UUID_FIELD in log


def test_with_action_logging_exploded_model_added_after(log_capture):
    std_out, std_err = log_capture

    with action_logging(field=123):
        add_fields(obj=TestExplodingModel({"name": "vic"}))

    assert 0 == len(std_err)
    assert 1 == len(std_out)

    log = std_out[0]

    assert 123 == log["field"]

    assert isinstance(log["obj"], dict), "Model was not exploded to primitive form!"
    assert "vic" == log["obj"]["name"]

    assert Constants.TASK_UUID_FIELD in log


def test_with_action_logging_exception(log_capture):
    _, std_err = log_capture

    try:
        with action_logging(field=123):
            num = 1 + 1

            add_fields(num=num)

            raise ValueError("Test")

    except ValueError:
        pass

    assert 1 == len(std_err)

    log = std_err[0]

    assert 2 == log["num"]
    assert 123 == log["field"]

    assert Constants.TASK_UUID_FIELD in log


def test_log_action(log_capture):
    std_out, _ = log_capture

    @log_action()
    def test_function():
        add_fields(field=123)

    test_function()

    assert 1 == len(std_out)

    log = std_out[0]

    assert 123 == log["field"]

    assert "test_function" == log[Constants.ACTION_FIELD]
    assert Constants.SUCCEEDED_STATUS == log[Constants.ACTION_STATUS_FIELD]


def test_log_action_with_args(log_capture):
    std_out, _ = log_capture

    @log_action(log_args=["_bob"])
    def test_function(_bob):
        add_fields(field=123)

    test_function("vic")

    assert 1 == len(std_out)

    log = std_out[0]

    assert 123 == log["field"]

    assert "test_function" == log[Constants.ACTION_FIELD]
    assert Constants.SUCCEEDED_STATUS == log[Constants.ACTION_STATUS_FIELD]

    assert "vic" == log["_bob"]


def test_log_action_with_model_exploded(log_capture):
    std_out, _ = log_capture

    @log_action(log_args=["_bob"])
    def test_function(_bob):
        add_fields(field=123)

    test_function(TestExplodingModel({"name": "vic"}))

    assert 1 == len(std_out)

    log = std_out[0]

    assert 123 == log["field"]

    assert "test_function" == log[Constants.ACTION_FIELD]
    assert Constants.SUCCEEDED_STATUS == log[Constants.ACTION_STATUS_FIELD]

    assert isinstance(log["_bob"], dict), "Model was not exploded to primitive form!"
    assert "vic" == log["_bob"]["name"]


def test_log_action_with_named_action(log_capture):
    std_out, _ = log_capture

    @log_action(action="test", log_args=["_bob"])
    def test_function(_bob):
        add_fields(field=123)

    test_function("vic")

    assert 1 == len(std_out)

    log = std_out[0]

    assert 123 == log["field"]

    assert "test" == log[Constants.ACTION_FIELD]
    assert Constants.SUCCEEDED_STATUS == log[Constants.ACTION_STATUS_FIELD]

    assert "vic" == log["_bob"]


def test_log_action_exception(log_capture):
    _, std_err = log_capture

    @log_action()
    def test_function():
        add_fields(field=123)
        raise ValueError("eek")

    try:
        test_function()
    except ValueError:
        pass

    assert 1 == len(std_err)

    log = std_err[0]

    assert 123 == log["field"]

    assert "test_function" == log[Constants.ACTION_FIELD]
    assert Constants.FAILED_STATUS == log[Constants.ACTION_STATUS_FIELD]


@pytest.mark.asyncio
async def test_async_logging_context_concurrent():
    logging_context.async_context_storage()

    @log_action()
    async def my_coro2(task_id: str):
        print(f"starting task {task_id}")
        res = await asyncio.gather(
            *[
                my_coro("task1", 1),
                my_coro("task2", 0.5),
                my_coro("task3", 0.25),
                my_coro("task4", 0.33),
            ]
        )
        print(f"ending task {task_id}")
        action = logging_context.current()
        return task_id, action.task_uuid, res  # type: ignore [union-attr]

    @log_action()
    async def my_coro(task_id: str, wait: float):
        action = logging_context.current()
        print(f"starting task {task_id}")
        await asyncio.sleep(wait)
        print(f"ending task {task_id}")
        return action.task_uuid  # type: ignore [union-attr]

    results = await asyncio.gather(
        *[
            my_coro2("2task1"),
            my_coro2("2task2"),
            my_coro2("2task3"),
            my_coro2("2task4"),
        ]
    )

    print(results)


@pytest.mark.asyncio
async def test_async_logging_context_linear():
    logging_context.async_context_storage()

    @log_action()
    async def my_coro2(task_id: str):
        print(f"starting task {id}")
        res = await my_coro("task3", 0.25)
        print(f"ending task {task_id}")
        action = logging_context.current()
        return task_id, action.task_uuid, res  # type: ignore [union-attr]

    @log_action()
    async def my_coro(task_id: str, wait: float):
        action = logging_context.current()
        print(f"starting task {task_id}")
        await asyncio.sleep(wait)
        print(f"ending task {task_id}")
        return action.task_uuid  # type: ignore [union-attr]

    results = await my_coro2("2task1")

    print(results)


@pytest.mark.asyncio
async def test_async_logging_context_concurrent_tasks():
    logging_context.async_context_storage()

    @log_action()
    async def my_coro2(task_id: str):
        print(f"starting task {task_id}")
        res = await asyncio.gather(
            *[
                await create_task(my_coro, "task1", 1),
                await create_task(my_coro, "task2", 0.5),
                await create_task(my_coro, "task3", 0.25),
                await create_task(my_coro, "task4", 0.33),
            ]
        )
        print(f"ending task {task_id}")
        action = logging_context.current()
        return task_id, action.task_uuid, res  # type: ignore [union-attr]

    @log_action()
    async def my_coro(task_id: str, wait: float):
        action = logging_context.current()
        print(f"starting task {task_id}")
        await asyncio.sleep(wait)
        print(f"ending task {task_id}")
        return action.task_uuid  # type: ignore [union-attr]

    results = await asyncio.gather(
        *[
            await create_task(my_coro2, "2task1"),
            await create_task(my_coro2, "2task2"),
            await create_task(my_coro2, "2task3"),
            await create_task(my_coro2, "2task4"),
        ]
    )

    print(results)


def test_concurrent_logging_context():
    @log_action()
    def my_task(task_id: str, wait: float):
        print("starting task {}".format(task_id))
        sleep(wait)
        print("ending task {}".format(task_id))
        return task_id

    results = concurrent_tasks(
        [
            ("task1", my_task, ["task1", 1]),
            ("task2", my_task, ["task2", 0.5]),
            ("task3", my_task, ["task3", 0.25]),
            ("task4", my_task, ["task4", 0.33]),
        ]
    )

    print(results)


def test_generator():
    @log_action()
    def inner_action() -> str:
        action = logging_context.current()
        return action.task_uuid  # type: ignore [union-attr, no-any-return]

    @log_action()
    def generator_action(count: int) -> Generator[str, None, None]:
        for _ in range(count):
            yield logging_context.current().task_uuid, inner_action()  # type: ignore [union-attr]

    @log_action()
    def outer_action():
        res = [r for r in generator_action(3)]
        action = logging_context.current()
        return action.task_uuid, res

    result = outer_action()

    print(result)


@pytest.mark.asyncio
async def test_async_logging_context_run_in_executor():
    logging_context.async_context_storage()

    @log_action()
    async def my_coro2(task_id: str):
        print("starting task {}".format(task_id))
        res = await asyncio.gather(
            *[
                await run_in_executor(my_io, "task1"),
                await run_in_executor(my_io, "task2", wait=0.5),
                await run_in_executor(my_io, "task3", wait=0.25),
                await run_in_executor(my_io, "task4", wait=0.33),
            ]
        )
        print("ending task {}".format(task_id))
        action = logging_context.current()
        return task_id, action.task_uuid, res  # type: ignore [union-attr]

    async def my_io(task_id: str, wait: float = 1):
        print(f"starting task {task_id}")
        time.sleep(wait)
        print(f"ending task {task_id}")
        return task_id

    results = await asyncio.gather(
        *[
            my_coro2("2task1"),
            my_coro2("2task2"),
            my_coro2("2task3"),
            my_coro2("2task4"),
        ]
    )

    print(results)
